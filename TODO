DONE

    Now think about what the server needs to do when it receives that connection request.

    First it needs to decrypt the token with the private key and nonce.

    If the token is invalid, ignore the connection request.

    If the token is valid, check that the server address is in the whitelist, if not, ignore the connection request.

    If the token client id is zero then ignore the connection request.

    Check the expiry timestamp of the connection request. If it is expired, ignore the connection request.

    At this point the connection request is valid.

    Setup the encryption mapping for the client/server pending connection.

    Is the server currently full? Reply with connection denied packet.

    If the particular client id is already connected, ignore the connection request. (is this the best thing to do? why not deny w. reason already connected?)

    Next take the HMAC of the connect token (first 16 bytes), and see if there is any entry for that HMAC (constant time)

    If there is a previous entry, check that it has the same address as this packet from address. If not, ignore the connection request.

    If there is no entry, add it and insert the network address the connection request came from with the HMAC.

TODO

    Now construct a challenge response token object.

    Encyrypt this challenge response token and bump the challenge response token nonce.

    Send a challenge response packet back to the client.

    ----------

    Is there a crypto attack on challenge response encryption, because different servers will encode the same data with difference nonces?

    No. The data has the server address in it, so data being encrypted is different on each machine.

    Perhaps also throw in some random bytes crap inside the challenge response?

    ----------

    Need to properly implement encryption mapping array in network interface

    ----------
