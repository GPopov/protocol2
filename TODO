CHANGES

    Make sure all serialize functions are getting called from test.cpp

TODO

    Add premake file for clean, make all etc. annoying to manually delete bins before checking in.

    Get building with maximum warning levels on clang.

    Get code building and running clean on windows.

    Compile with a gcc on linux.

    Ready to write article.

=========================

For article in order, start with different options, eg. xml, json, key value, protobuf, capn proto, flatbuffers etc.

Discuss why game network protocols are usually not a good fit for this (version is not a problem, because different
versions of the game don't talk to each other...), bandwidth is most important, we want to only send data that is
essential, zero overhead. binary not text. => completely unattributed stream of data.

First attempt. send structs. fails because of endianness. (discussion of endianness)

next, basic read/write methods, eg. read int, write int, read byte, write byte etc. short, float etc.

separate read and write functions for packets. show what they look like.

first start writing local variables, eg. read data and process it in same function.

soon, you realize you often want to read data into a struct and separate the serialization (read/write) from the processing of the packet.

fails because often quantities are one bit only. very wasteful to spend one byte (8 bits) to send just one bit of information.

but a good start, because it is now endian correct.

bitpacker.

(maybe bitpacker can work with 128bit words, and then we can write 32 and 64 bit quantities to the bit stream in one go, work out overflow, and flush while > 32 bits in int?)

separate read/write functions.

easy to desync these functions, hard to track down where you went wrong.

go into details about algorithm for bitpacker (write word at a time, overflow, diagrams etc.)

solution: unify serialization function

concept of "stream". read/write mode.

avoid runtime overhead by using templates to generate optimal code for read and write.

can also have a "measure" stream for when you need to know how large something would be when encoded (all encodings are variable length, so sometimes you need to know this!)

(probably want more examples with bools in them)

need to be really safe on read. macros that return false if anything doesn't check out. DON'T USE EXCEPTIONS THEY'RE REALLY SLOW

write doesn't need to be as safe. write can assert. it's YOUR fault if you fuck up the write function and overflow bits. it shouldn't happen in production code.

redundancy. also, don't serialize # of bits for ints, instead prefer to serialize within a min/max range.

that way anything that comes in outside that range can automatically be rejected and return false (aborting the packet read)

now onto more detais about reading and writing packets

 - crc32, basic properties.
 - protocol id -- pre-header concept
 - maliciously constructed packets: need to be really safe on read (don't crash!)
 - serialize checks: end of packet. it's easy to send a truncated packet and not notice because the serialization stops (or aborts reading zeros...). adding a serialize check at the end fixes this.
 - packet journal: possible to also insert a sequence of what was written vs. what was read in another form, for validation. (blows out packet size, you'll need packet fragmentation and re-assembly to support this)

serialization examples:

...

how to go even further: range encoding. fractional bits. models. link to Fabian Giesen's example code.

next article link

=========================

For article (no particular order)

Cover checksum, possibility of corruption even with UDP checksum (16bit only)

How to write signed integers (the alternating +/-)

Floating point quantization and the +0.5 that must happen.

Other ways to write (eg. proto buffers, flatbuffers, xml, yaml etc)

Unattributed stream. We know lots of data is the same on both sides, eg. the type and bounds of a particular variable.

Matching read/write functions.

Structs. Different compilers may have different layouts/alignment. Also pointers. Can't just send those over the network.

Little and big endian.

Bitpacker working one byte at a time. Machines don't work this way.

Bitpacker working a machine word at a time (32bit), and working internally with 64bit integer. Much more modern.

The basic library (open source part) is the serializer, bitpacker, packet read/write, factory etc.

Then in later articles I can develop more example source code using this common code (the serializer) to build interesting things.

This is a good way to structure the library so that a "taste" is for free (and a very useful part...), and it is a one header library, as well as being very useful on its own, and not bloated.

Make sure that the example code does not use a bunch of STL. But don't worry too much about hardening it. eg. use "asserts" raw, use printfs, and don't use modern C++. use new/delete. If somebody wants to take this code and integrate it into their engine it should be work. This is not a middleware product.

Cover the unified serialize function.

Cover serialize read/write and template usage.

Extend tests to cover a bunch of different integer types, including bitfields.

Add examples in the article for serializing vectors, quaternions (useful).

Encoding relative integers.

Encoding quaternions with smallest three.

Encoding a value relative to another, eg. a position relative to another position.

Encoding an array of values.

Encoding a string.

Alignment of serialization.

Serialization checkpoints for safety.

Flush bits at the end of write.

Maybe extend to support seeking?

Need more unit tests for stream. They don't exercise everything.

PopCount and the code that calculates the bits required via template (compile time)

Would be nice if I could remember that trick for encoding normals from pandemic.

Common pattern of serializing a flag (bit) and if true then branching, else serialize something else.

Safety when reading and writing packets: if overflowing, don't write. If reading past end of buffer, always read zeros.

Generally, assert heavily while writing packets. While reading packets, if anything is incorrect, drop the packet.
