DONE

    Hacked up a really simple data structure. Not implement

    Add counters to print out at the end of the packet encryption test

    Make sure everything is working OK

    Seems fine.

    Fix the salt timeout it's broken

    Search through additional todos. Seems fine. Added some more notes.

    Specifically, I want a way to genericalyl abort packet read at the TYPE level, if that type is not allowed for some reason.

    eg. a type that the server doesn't expect, *or* an unencrypted packet for a type that should be encrypted and so on.

    This part is probably important to do before saying the packet encryption part is finished, because that's a key part of being secure.

    Don't let the client just get in under the covers with an unencrypted packet!

    Doing this now...

    OK. This is pretty clean. I like the PacketInfo approach for extending read and write packets.

    Get the code compiling on windows (install sodium)

    Wow. It's totally fucked up again. How?!

    First step, disable sodium by implementing #define YOJIBO_SECURE

    If this is not defined, you can strip out all the security support.

    Got the security stripped out and got everything working on Mac and Linux.

    PRIx64 WTF. gross...

    Now back to windows.

    Repaired the Visual Studio installation. Really I don't have any other explanation for why it is busted other than corruption.

    I don't know what is going on here.

    WINDOWS

    It's fucked up because I included the sockets implementation, which probably needs more headers.

    Without the sockets class it's fine. What else needs to be included for sockets?

    Actually, it was some weird ass s_addr #define shit. Ugh. Fixed.

    Now turn back on YOJIMBO_SECURE and get it working under linux.

    Done. Had to make from source and then run "ldconfig" to update shared libraries after installing.

    Now bring it back into windows and get sodium working and installing there.

    Package up something for supporters this month. It should make them happy, but be low key about it.

    Kinda brought sodium up and working in windows. Bundling it seems to make the most sense.

    Some errors with I think uint8_t pointer access through my uint64_t for the sequence #

    Hopefully this can be fixed, windows is complaining about it but mac and linux working fine.

    Should add packet encrypt/decrypt tests as well as AEAD tests to tests.cpp #if HAS( YOJIMBO_SECURE )
    
    No dice. There is nothing wrong with the sequence number compress/decompress.

    I'm doing something wrong, either undefined behavior (three different compilers bitching about something = MY FAULT)

    or memory trash

    or stack trash or something.

    Not sure yet!

    Have to find it. Can't put this code out there without this.

    With the simplified code, the decrypts work in windows and mac, but now fail on linux.

    Could it be that linux does not like:

        a) unaligned decrypt

        b) decrypt in place?

    Lets try some experiments...

    Seems like linux just doesn't want to decrypt at all. Broken libsodium?

    Add a test for sodium packet encrypt/decrypt in lib sodium.

    Passes. I now suspect stack trashing and/or memory trashing.

    Try not using the stupid yojimbo allocator. See if that fixes it.

    Long shot. Didn't seem to help at all.

    I really don't know what is going on.

    This is fucked. =p

    By taking a block that fails to decrypt on the server, and inputting it, it also fails to decrypt on mac.

    This indicates to me that something is going wrong in the ENCRYPT level. eg. it is encrypting to crap, for some reason,
    and this encrypted block cannot be decrypted because it it trashed.

    Idea: Pass in known packet bytes, eg. packet of size 1 with contents [ 1 ] and see what it encrypts to on linux vs. on mac.

TODO

    OK. I've actually fucking caught it doing stupid crap in linux now. I have a small trivial test where on linux it fails,
    and gives random encrypted packets, while no macosx it hits a proper fixed encoding.

    I think this isolates the bug on linux. 

    I also don't think it's mine.

    You know what would fit. If the simple box nonce was larger than the bytes specified, or the key.

    Yeah that would certainly explain what I'm seeing...

    Found it. The key and nonce sizes are different for the simplebox.

    Fuck me.
