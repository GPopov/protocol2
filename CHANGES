
Thursday December 24th, 2015
============================

    Mostly fleshed out new FragmentPacket structure with serialize function

    Finish implementation of fragment packet serialize, especially bit where fragmentSize is inferred.

    On read, make sure fragment size is clamped and checked to be in range, and if outside range we just
    abort the serialize vs. feeding into serialize_bytes.

    Converted code that writes packet fragment to use serialize write functions on stream.

    Removed "Fragment" struct and replaced with two arrays.


Wednesday December 23rd, 2015
=============================

    At this point it's starting to feel that integrating support for fragments into the protocol2.h is worth considering

    Here are the pros of that:

        1. It's done once and it works for all other articles past this
        2. It's reusable and exists for other examples without extra work
        3. There is very little overhead with the approach of reserving packet type 0 for fragments
        4. It's really annoying mirroring the packet read/write functions specially to handle fragments, it's also error prone

    Cons:

        1. It significantly complicates protocol2.h
        2. It turns protocol2.h from a stateless header into something that maintains a data structure
        3. The data structure has a lot of assumptions built in, like maximum number of fragments per-packet, max fragment size and so on.
        4. Baggage to support fragmentation and re-assembly is carried across to other articles that don't need it
        5. Now there are multiple versions of protocol2.h for each article *or* the protocol2.h gets really bulky, eg. lots of extra stuff
        6. I'm not really making middleware here, but a bunch of articles showing how stuff is done. It's good for each article to basically
           be self-contained. If somebody really wants the middleware for protocol2.h to be integrated together into a product they can
           pay me to do that for them.
        7. If I make this decision now, suddenly other things specific to articles will also get carried across to protocol2.h past this point
        8. I'd really like to keep protocol2.h as simple as possible and not turn it into a library.

    At the moment, I think I'm going to move forward with mirroring the packet read/write in the 002 article source code.


Tuesday December 8th, 2015
=========================

    Implement packet header object and pass it in to the 002_* example source code.

    Packet header just contains uint16_t sequence.

    Need a function to swap uint16_t to network, back to host order etc.

    Insert sequence into fragment packet

    Insert fragment id into fragment packet

    Insert total fragments into fragment packet

    Sketched out "ProcessPacket" function

    Hooked up so it gets called. Verified that it correctly distinguishes between fragment and non-fragmented packets.

    Added code to receive packets from packet buffer, vs. reading them directly off the packet write buffer.
    
    Parse the rest of the packet fragment header. Print out the results as procesing each packet, eg. x/y of packet n

    Parse the sequence number out of the regular packet too and print that.

    Pass to the process packet inside the packet buffer.

    Sequence number is not parsing correctly for non-fragmented packets. Is it getting written correctly?!

    I think there is a difference with what is written through the serialize vs. what is written if I read/write
    manually.

    It seems that I have to go through serialization always.

    Explore this.

    Write some code that determines what the byte order is for writing bytes at a time and shorts.

    eg. 0x10,0x11,0x12,0x13 for bytes

    or: 0x1111 and 0x2222 for shorts

    My guess is that I may have some code that switches the bit order of what I write.

    Confirmed. Serializing 0x11, 0x22, 0x33, 0x44 results in reading 0x33, 0x44 in the high word.

    So this means that writing one dword at a time is switching around the shorts.

    I'm pretty sure this means I need to go through the serializer all the time.
    

Sunday December 6th, 2015
=========================

    Sketch out data structure for packet buffer

    Implement advance function for packet buffer.

    Implement process fragment function for packet buffer.

    Sketch out function to split packet into fragments

    Sketch out code to process incoming packets and pass them to the packet buffer.

    Sketch out code to get packets from packet buffer in one loop

    Almost finished function to split packets apart into fragment packets

    Converted remaining comment pseudocode into code for the split packet function.

    Added "Header" protocol object which provides an in for the user creating their own header for packets.


November 30th, 2015
===================

    Make sure all serialize functions are getting called from test.cpp

    Add premake file for clean, make all etc. annoying to manually delete bins before checking in.

    Fix a bunch of bullshit with dev environment being broken by el capitan

    Get building with maximum warning levels on clang.

    Fix compiler warnings in release build (check macro needs to not be assert)

    Make sure it builds and works in release and debug builds.

    Clean up test to consolidate the context into the one test_stream function.


November 29th, 2015
===================

    Convert stream errors to PROTOCOL2_ERROR_* form and add to error_string fn.

    Fix GCC specific stuff (eg. __builtin_bswap etc)

    Make sure stream properly handles overflow on read. On write, stream should assert (it's your fault!)

    Split rest of existing template serialize fns to serialize_x_internal and wrap with macros for return false.

    Move the packet factory into implementation section.

    Make a list of all serialize functions to test.

        1. serialize_int
        2. serialize_bits
        3. serialize_bool
        4. serialize_float
        5. serialize_uint64
        6. serialize_double
        7. serialize_bytes
        8. serialize_string
        9. serialize_align
        10. serialize_check
        11. serialize_object


November 25th, 2015
===================

    Fixed weird serialization error.

    Make sure code doesn't blow up if only one packet is defined.

    Handle the protocol id in the checksum calculation, eg. pre-header

    Add code to get strings for various enums (especially error codes)

    Add comparison operators (==) to test packet types.

    Verify the packets received match the packet data sent.


October 21st, 2015
==================

    Implement unit tests

    Sketched out packet read/write for article 001

    Added concept of multiple errors: overflow, invalid, abort

    GetError() returns 0 if no error (PROTOCOL2_STREAM_ERROR_NONE)

    Make SerializeInteger return true/false on success/failure again

    Update macros to return false on failure

    Make sure there is not double checking for overflow (stream and bit reader etc.)

    Find public domain CRC32 implementation

    Clean up the CRC impl.

    Write functions to calculate packet CRC

    Move read and write packet into protocol2.h (generally useful)

    Split apart protocol2.h into implementation and header, STB style.

    Add enum for packet read error. Packet write error can only have one cause (serialize write failure), and you can already check it on the stream.

    Add more interesting serialization examples to make up the packets, eg. an array of things, a string, some byte data, position/velocity with at rest flag.

    Randomize the data sent in the packets

    Add prints showing the numbers of bytes in packets

    Added serialize_float (uncompressed)
